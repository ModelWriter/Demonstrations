<alloy builddate="2012-09-25 15:54 EDT">

<instance bitwidth="0" maxseq="0" command="Run run$1 for exactly 3 Configuration" filename="/home/harun/git/Demonstrations/eu.modelwriter.demonstration.alloyinecore/harun/Alloy/Improved Feature Model/Model_3/instance_for_model_3_4.als">

<sig label="seq/Int" ID="0" parentID="1" builtin="yes">
</sig>

<sig label="Int" ID="1" parentID="2" builtin="yes">
</sig>

<sig label="String" ID="3" parentID="2" builtin="yes">
</sig>

<sig label="this/A" ID="4" parentID="5" one="yes">
   <atom label="A$0"/>
</sig>

<sig label="this/B" ID="6" parentID="5" one="yes">
   <atom label="B$0"/>
</sig>

<sig label="this/C" ID="7" parentID="5" one="yes">
   <atom label="C$0"/>
</sig>

<sig label="this/D" ID="8" parentID="5" one="yes">
   <atom label="D$0"/>
</sig>

<sig label="this/E" ID="9" parentID="5" one="yes">
   <atom label="E$0"/>
</sig>

<sig label="Combined/Feature" ID="5" parentID="2" abstract="yes">
</sig>

<sig label="Combined/FeatureModel/EmptyFeatureModel" ID="10" parentID="11" one="yes">
   <atom label="Combined/FeatureModel/EmptyFeatureModel$0"/>
</sig>

<sig label="Combined/FeatureModel/GivenFeatureModel" ID="12" parentID="11" one="yes">
   <atom label="Combined/FeatureModel/GivenFeatureModel$0"/>
</sig>

<sig label="Combined/FeatureModel/FeatureModel" ID="11" parentID="2" abstract="yes">
</sig>

<field label="depend" ID="13" parentID="11">
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="A$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="A$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="A$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="A$0"/> <atom label="D$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="A$0"/> <atom label="E$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="B$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="B$0"/> <atom label="D$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="B$0"/> <atom label="E$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="C$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="D$0"/> <atom label="D$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="E$0"/> <atom label="E$0"/> </tuple>
   <types> <type ID="11"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="mandatory" ID="14" parentID="11">
   <types> <type ID="11"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="optional" ID="15" parentID="11">
   <types> <type ID="11"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="alternative" ID="16" parentID="11">
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="B$0"/> <atom label="D$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="B$0"/> <atom label="E$0"/> </tuple>
   <types> <type ID="11"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="_or" ID="17" parentID="11">
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="A$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="A$0"/> <atom label="C$0"/> </tuple>
   <types> <type ID="11"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="requires" ID="18" parentID="11">
   <types> <type ID="11"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="excludes" ID="19" parentID="11">
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="B$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/GivenFeatureModel$0"/> <atom label="C$0"/> <atom label="B$0"/> </tuple>
   <types> <type ID="11"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<sig label="Combined/FeatureModel/Configuration" ID="20" parentID="2">
   <atom label="Combined/FeatureModel/Configuration$0"/>
   <atom label="Combined/FeatureModel/Configuration$1"/>
   <atom label="Combined/FeatureModel/Configuration$2"/>
</sig>

<field label="includes" ID="21" parentID="20">
   <tuple> <atom label="Combined/FeatureModel/Configuration$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/Configuration$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/Configuration$1"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/Configuration$1"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/Configuration$1"/> <atom label="E$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/Configuration$2"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/Configuration$2"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/FeatureModel/Configuration$2"/> <atom label="D$0"/> </tuple>
   <types> <type ID="20"/> <type ID="5"/> </types>
</field>

<sig label="Combined/RequirementsModel/EmptyModel" ID="22" parentID="23" one="yes">
   <atom label="Combined/RequirementsModel/EmptyModel$0"/>
</sig>

<sig label="Combined/RequirementsModel/GivenModel" ID="24" parentID="23" one="yes">
   <atom label="Combined/RequirementsModel/GivenModel$0"/>
</sig>

<sig label="Combined/RequirementsModel/InferredModel" ID="25" parentID="23" one="yes">
   <atom label="Combined/RequirementsModel/InferredModel$0"/>
</sig>

<sig label="Combined/RequirementsModel/RequirementsModel" ID="23" parentID="2" abstract="yes">
</sig>

<field label="requires" ID="26" parentID="23">
   <types> <type ID="23"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="refines" ID="27" parentID="23">
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="B$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="C$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="D$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="E$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="B$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="C$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="D$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="D$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="E$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="E$0"/> <atom label="B$0"/> </tuple>
   <types> <type ID="23"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="contains" ID="28" parentID="23">
   <types> <type ID="23"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="partiallyRefines" ID="29" parentID="23">
   <types> <type ID="23"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="conflicts" ID="30" parentID="23">
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="B$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="C$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="D$0"/> <atom label="E$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/GivenModel$0"/> <atom label="E$0"/> <atom label="D$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="B$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="C$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="C$0"/> <atom label="D$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="C$0"/> <atom label="E$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="D$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="D$0"/> <atom label="E$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="E$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="E$0"/> <atom label="D$0"/> </tuple>
   <types> <type ID="23"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<field label="equals" ID="31" parentID="23">
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="A$0"/> <atom label="A$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="B$0"/> <atom label="B$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="C$0"/> <atom label="C$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="D$0"/> <atom label="D$0"/> </tuple>
   <tuple> <atom label="Combined/RequirementsModel/InferredModel$0"/> <atom label="E$0"/> <atom label="E$0"/> </tuple>
   <types> <type ID="23"/> <type ID="5"/> <type ID="5"/> </types>
</field>

<sig label="univ" ID="2" builtin="yes">
</sig>

<sig label="Combined/Optional" ID="32">
   <atom label="B$0"/>
   <atom label="C$0"/>
   <atom label="D$0"/>
   <atom label="E$0"/>
   <type ID="5"/>
</sig>

<sig label="Combined/Mandatory" ID="33">
   <atom label="A$0"/>
   <type ID="5"/>
</sig>

<sig label="Combined/FeatureModel/Root" ID="34" one="yes">
   <atom label="A$0"/>
   <type ID="5"/>
</sig>

</instance>

<source filename="/home/harun/git/Demonstrations/eu.modelwriter.demonstration.alloyinecore/harun/Alloy/Improved Feature Model/Model_3/instance_for_model_3_4.als" content="open combined_feature_model as Combined&#x000a;&#x000a;one sig A extends Feature {}&#x000a;one sig B extends Feature {}&#x000a;one sig C extends Feature {}&#x000a;one sig D extends Feature{}&#x000a;one sig E extends Feature{}&#x000a;&#x000a;fact init_feature_model {&#x000a;&#x0009;Combined/FeatureModel/Root[A]&#x000a;&#x000a;&#x0009;Combined/FeatureModel/NoMandatory&#x000a;/*&#x000a;&#x0009;Combined/FeatureModel/NoAlternative&#x000a;&#x0009;Combined/FeatureModel/Optional[B -&gt; D]&#x000a;*/&#x000a;&#x0009;Combined/FeatureModel/Alternative[B -&gt; (D + E)]&#x000a;&#x0009;Combined/FeatureModel/NoOptional&#x000a;&#x0009;Combined/FeatureModel/Or[A -&gt; (B + C)]&#x000a;&#x0009;Combined/FeatureModel/NoRequires&#x000a;&#x0009;Combined/FeatureModel/Excludes[B -&gt; C]&#x000a;}&#x000a;&#x000a;fact {&#x000a;&#x0009;Combined/ConvertFeatureModel&#x000a;}&#x000a;&#x000a;run {} for exactly 3 Configuration&#x000a;"/>

<source filename="/$alloy4$/models/util/integer.als" content="module util/integer&#x000a;&#x000a;/*&#x000a; * A collection of utility functions for using Integers in Alloy.&#x000a; * Note that integer overflows are silently truncated to the current bitwidth&#x000a; * using the 2&apos;s complement arithmetic, unless the &quot;forbid overfows&quot; option is&#x000a; * turned on, in which case only models that don&apos;t have any overflows are &#x000a; * analyzed. &#x000a; */&#x000a;&#x000a;fun add  [n1, n2: Int] : Int { this/plus[n1, n2] }&#x000a;fun plus [n1, n2: Int] : Int { n1 fun/add n2 }&#x000a;&#x000a;fun sub   [n1, n2: Int] : Int { this/minus[n1, n2] }&#x000a;fun minus [n1, n2: Int] : Int { n1 fun/sub n2 }&#x000a;&#x000a;fun mul [n1, n2: Int] : Int { n1 fun/mul n2 }&#x000a;&#x000a;/**&#x000a; * Performs the division with &quot;round to zero&quot; semantics, except the following 3 cases&#x000a; * 1) if a is 0, then it returns 0&#x000a; * 2) else if b is 0, then it returns 1 if a is negative and -1 if a is positive&#x000a; * 3) else if a is the smallest negative integer, and b is -1, then it returns a&#x000a; */&#x000a;fun div [n1, n2: Int] : Int { n1 fun/div n2 }&#x000a;&#x000a;/** answer is defined to be the unique integer that satisfies &quot;a = ((a/b)*b) + remainder&quot; */&#x000a;fun rem [n1, n2: Int] : Int { n1 fun/rem n2 }&#x000a;&#x000a;/** negate */&#x000a;fun negate [n: Int] : Int { 0 fun/sub n }&#x000a;&#x000a;/** equal to */&#x000a;pred eq [n1, n2: Int] { int[n1] = int[n2] }&#x000a;&#x000a;/** greater than */&#x000a;pred gt [n1, n2: Int] { n1 &gt; n2 }&#x000a;&#x000a;/** less then */&#x000a;pred lt [n1, n2: Int] { n1 &lt; n2 }&#x000a;&#x000a;/** greater than or equal */&#x000a;pred gte [n1, n2: Int] { n1 &gt;= n2 }&#x000a;&#x000a;/** less than or equal */&#x000a;pred lte [n1, n2: Int] { n1 &lt;= n2 }&#x000a;&#x000a;/** integer is zero */&#x000a;pred zero [n: Int] { n = 0 }&#x000a;&#x000a;/** positive */&#x000a;pred pos  [n: Int] { n &gt; 0 }&#x000a;&#x000a;/** negative */&#x000a;pred neg  [n: Int] { n &lt; 0 }&#x000a;&#x000a;/** non-positive */&#x000a;pred nonpos [n: Int] { n &lt;= 0 }&#x000a;&#x000a;/** non-negative */&#x000a;pred nonneg [n: Int] { n &gt;= 0 }&#x000a;&#x000a;/** signum (aka sign or sgn) */&#x000a;fun signum [n: Int] : Int { n&lt;0 =&gt; (0 fun/sub 1) else (n&gt;0 =&gt; 1 else 0) }&#x000a;&#x000a;/**&#x000a; * returns the ith element (zero-based) from the set s&#x000a; * in the ordering of &apos;next&apos;, which is a linear ordering&#x000a; * relation like that provided by util/ordering&#x000a; */&#x000a;fun int2elem[i: Int, next: univ-&gt;univ, s: set univ] : lone s {&#x000a;  {e: s | #^next.e = int i }&#x000a;}&#x000a;&#x000a;/**&#x000a; * returns the index of the element (zero-based) in the&#x000a; * ordering of next, which is a linear ordering relation&#x000a; * like that provided by util/ordering&#x000a; */&#x000a;fun elem2int[e: univ, next: univ-&gt;univ] : lone Int {&#x000a;  Int[#^next.e]&#x000a;}&#x000a;&#x000a;/** returns the largest integer in the current bitwidth */&#x000a;fun max:one Int { fun/max }&#x000a;&#x000a;/** returns the smallest integer in the current bitwidth */&#x000a;fun min:one Int { fun/min }&#x000a;&#x000a;/** maps each integer (except max) to the integer after it */&#x000a;fun next:Int-&gt;Int { fun/next }&#x000a;&#x000a;/** maps each integer (except min) to the integer before it */&#x000a;fun prev:Int-&gt;Int { ~next }&#x000a;&#x000a;/** given a set of integers, return the largest element */&#x000a;fun max [es: set Int]: lone Int { es - es.^prev }&#x000a;&#x000a;/** given a set of integers, return the smallest element */&#x000a;fun min [es: set Int]: lone Int { es - es.^next }&#x000a;&#x000a;/** given an integer, return all integers prior to it */&#x000a;fun prevs [e: Int]: set Int { e.^prev }&#x000a;&#x000a;/** given an integer, return all integers following it */&#x000a;fun nexts [e: Int]: set Int { e.^next }&#x000a;&#x000a;/** returns the larger of the two integers */&#x000a;fun larger [e1, e2: Int]: Int { let a=int[e1], b=int[e2] | (a&lt;b =&gt; b else a) }&#x000a;&#x000a;/** returns the smaller of the two integers */&#x000a;fun smaller [e1, e2: Int]: Int { let a=int[e1], b=int[e2] | (a&lt;b =&gt; a else b) }&#x000a;"/>

<source filename="/home/harun/git/Demonstrations/eu.modelwriter.demonstration.alloyinecore/harun/Alloy/Improved Feature Model/Model_3/combined_feature_model.als" content="module combined_feature_model&#x000a;&#x000a;open feature_model_3[Feature] as FeatureModel&#x000a;open requirements_model[Feature] as RequirementsModel&#x000a;&#x000a;/** ModelObject must be extended by all the other model signatures */&#x000a;abstract sig Feature {}&#x000a;&#x000a;sig Optional, Mandatory in Feature {}&#x000a;&#x000a;/** Converts the Feature model into a requirements model */&#x000a;pred ConvertFeatureModel {&#x000a;&#x0009;let fm = FeatureModel/GivenFeatureModel {&#x000a;&#x0009;&#x0009;RequirementsModel/Requires[fm.requires + fm.mandatory]&#x000a;&#x0009;&#x0009;RequirementsModel/Refines[~(fm.(optional + alternative + _or))]&#x000a;&#x000a;&#x0009;&#x0009;all f: Feature | f.(RequirementsModel/GivenModel.conflicts) =  f.(fm.excludes) + (f.~(fm.alternative).(fm.alternative) - f)&#x000a;&#x000a;&#x0009;&#x0009;RequirementsModel/NoContains&#x000a;&#x0009;&#x0009;RequirementsModel/NoPartiallyRefines&#x000a;&#x0009;&#x0009;RequirementsModel/NoEquals&#x000a;&#x000a;&#x0009;&#x0009;Mandatory = FeatureModel/Root.*(fm.mandatory) // all features which are reachable from Root only by &quot;mandatory&quot; are mandatory in requirements model and the rest are optional.&#x000a;&#x0009;&#x0009;Feature - Mandatory = Optional&#x000a;&#x0009;}&#x000a;}&#x000a;"/>

<source filename="/home/harun/git/Demonstrations/eu.modelwriter.demonstration.alloyinecore/harun/Alloy/Improved Feature Model/Model_3/feature_model_3.als" content="/** Takes a user defined signature and defines the relations according to it. */&#x000a;module feature_model_3[Feature]&#x000a;&#x000a;open util/relation&#x000a;&#x000a;one sig Root in Feature {}&#x000a;&#x000a;abstract sig FeatureModel {&#x000a;&#x0009;depend: Feature -&gt; Feature,&#x000a;&#x0009;mandatory: Feature -&gt; Feature,&#x000a;&#x0009;optional: Feature -&gt; Feature,&#x000a;&#x0009;alternative: Feature -&gt; Feature,&#x000a; &#x0009;_or: Feature -&gt; Feature,&#x000a;&#x000a;&#x0009;requires: Feature -&gt; Feature,&#x000a;&#x0009;excludes: Feature -&gt; Feature&#x000a;}&#x000a;&#x000a;/** EmptyFeatureModel is the model that has no relations, GivenFeatureModel is the model that user defines */&#x000a;one sig EmptyFeatureModel, GivenFeatureModel extends FeatureModel {}&#x000a;&#x000a;/** Abstract Syntax */&#x000a;fact {&#x000a;&#x0009;well_formedness[GivenFeatureModel]&#x000a;&#x0009;NoRelations[EmptyFeatureModel]&#x000a;&#x0009;//Root.*FeatureModel.(mandatory + optional + alternative + _or + requires + excludes)  =  Feature// Any feature, connected to this model, must be reachable from the root.&#x000a;}&#x000a;&#x000a;private pred well_formedness[m: FeatureModel] {&#x000a;&#x0009;m.(mandatory + optional + alternative + _or) in m.depend&#x000a;&#x000a;&#x0009;no m.mandatory &amp; m.optional&#x000a;&#x0009;no m.mandatory &amp; m.alternative&#x000a;&#x0009;no m.mandatory &amp; m._or&#x000a;&#x0009;no m.mandatory &amp; m.requires&#x000a;&#x0009;no m.mandatory &amp; m.excludes&#x000a;&#x000a;&#x0009;no m.optional &amp; m.alternative&#x000a;&#x0009;no m.optional &amp; m._or&#x000a;&#x0009;no m.optional &amp; m.requires&#x000a;&#x0009;no m.optional &amp; m.excludes&#x000a;&#x000a;&#x0009;no m.alternative &amp; m._or&#x000a;&#x0009;no m.alternative &amp; m.requires&#x000a;&#x0009;no m.alternative &amp; m.excludes&#x000a;&#x000a;&#x0009;no m._or &amp; m.requires&#x000a;&#x0009;no m._or&amp; m.excludes&#x000a;&#x000a;&#x0009;no m.requires &amp; m.excludes&#x000a;&#x000a;&#x0009;no m.mandatory &amp; ~(m.optional)&#x000a;&#x0009;no m.mandatory &amp; ~(m.alternative)&#x000a;&#x0009;no m.mandatory &amp; ~(m._or)&#x000a;&#x0009;no m.mandatory &amp; ~(m.requires)&#x000a;&#x0009;no m.mandatory &amp; ~(m.excludes)&#x000a;&#x000a;&#x0009;no m.optional &amp; ~(m.alternative)&#x000a;&#x0009;no m.optional &amp; ~(m._or)&#x000a;&#x0009;no m.optional &amp; ~(m.requires)&#x000a;&#x0009;no m.optional &amp; ~(m.excludes)&#x000a;&#x000a;&#x0009;no m.alternative &amp; ~(m._or)&#x000a;&#x0009;no m.alternative &amp; ~(m.requires)&#x000a;&#x0009;no m.alternative &amp; ~(m.excludes)&#x000a;&#x000a;&#x0009;no m._or &amp; ~(m.requires)&#x000a;&#x0009;no m._or &amp; ~(m.excludes)&#x000a;&#x000a;&#x0009;no m.requires &amp; ~(m.excludes)&#x000a;&#x000a;&#x0009;irreflexive[m.mandatory]&#x000a;&#x0009;irreflexive[m.optional]&#x000a;&#x0009;irreflexive[m.alternative]&#x000a;&#x0009;irreflexive[m._or]&#x000a;&#x0009;irreflexive[m.requires]&#x000a;&#x0009;irreflexive[m.excludes]&#x000a;&#x0009;antisymmetric[m.mandatory]&#x000a;&#x0009;antisymmetric[m.optional]&#x000a;&#x0009;antisymmetric[m.alternative]&#x000a;&#x0009;antisymmetric[m._or]&#x000a;&#x0009;antisymmetric[m.requires]&#x000a;&#x000a;&#x0009;all f: Feature | f in Root.(m.depend)&#x000a;&#x0009;partialOrder[m.depend, Feature]&#x000a;&#x0009;all f: Feature - Root | one f.~(m.(mandatory + optional + alternative + _or))&#x000a;}&#x000a;&#x000a;/** Configuration Semantics */&#x000a;// There are instances that includes features.&#x000a;sig Configuration {&#x000a;&#x0009;includes: set Feature&#x000a;}&#x000a;&#x000a;// There are not two equal instances.&#x000a;fact all_configurations_unique {&#x000a;&#x0009;all i: Configuration, i&apos;: Configuration-i | i.includes != i&apos;.includes&#x000a;}&#x000a;&#x000a;fact diversity_rules {&#x000a;&#x0009;all i: Configuration {&#x000a;&#x0009;&#x0009; Root in i.includes&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;/** root */&#x000a;&#x0009;&#x0009;all f1: Feature, f2: f1.(FeatureModel.optional) | f2 in i.includes =&gt; f1 in i.includes &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;/** optional */&#x000a;&#x0009;&#x0009;all f1: Feature, f2: f1.(FeatureModel.mandatory) | f2 in i.includes &lt;=&gt; f1 in i.includes &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;/** mandatory */&#x000a;&#x0009;&#x0009;all f1: Feature | f1 in i.includes and some f1.(FeatureModel._or) &lt;=&gt; some f1.(FeatureModel._or) &amp; i.includes &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;/** or */&#x000a;&#x0009;&#x0009;all f1: Feature | f1 in i.includes and some f1.(FeatureModel.alternative) &lt;=&gt; some f1.(FeatureModel.alternative) &amp; i.includes&#x0009;&#x0009;&#x0009;/** alternative (1) */&#x000a;&#x0009;&#x0009;all f1: i.includes, f2: f1.(FeatureModel.alternative), f3: f1.(FeatureModel.alternative) - f2 | !(f2 in i.includes and f3 in i.includes) &#x0009;&#x0009;/** alternative (2) */&#x000a;&#x0009;&#x0009;all f1: Feature, f2: f1.(FeatureModel.requires) | f1 in i.includes =&gt; f2 in i.includes&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;/** requires */&#x000a;&#x0009;&#x0009;all f1: Feature, f2: f1.(FeatureModel.excludes) | !(f1 in i.includes and f2 in i.includes) &#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;/** excludes */&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;&#x000a;/** Predicates to define partial configurations */&#x000a;&#x000a;pred Root[f: Feature] {&#x000a;&#x0009;Root = f&#x000a;}&#x000a;&#x000a;pred Mandatory[f1, f2: one Feature] {&#x000a;&#x0009;f1 -&gt; f2 in GivenFeatureModel.mandatory&#x000a;}&#x000a;&#x000a;pred Optional[f1, f2: Feature] {&#x000a;&#x0009;f1 -&gt; f2 in GivenFeatureModel.optional&#x000a;}&#x000a;&#x000a;pred Alternative[f1: Feature, f2: Feature] {&#x000a;&#x0009;f1 -&gt; f2 in GivenFeatureModel.alternative&#x000a;}&#x000a;&#x000a;pred Or[f1, f2: Feature] {&#x000a;&#x0009;f1 -&gt; f2 in GivenFeatureModel._or&#x000a;}&#x000a;&#x000a;pred Requires[f1, f2: Feature] {&#x000a;&#x0009;f1 -&gt; f2 in GivenFeatureModel.requires&#x000a;}&#x000a;&#x000a;pred Excludes[f1, f2: Feature] {&#x000a;&#x0009;f1 -&gt; f2 in GivenFeatureModel.excludes&#x000a;}&#x000a;&#x000a;pred Mandatory[r: Feature -&gt; Feature] {&#x000a;&#x0009;r = GivenFeatureModel.mandatory&#x000a;}&#x000a;&#x000a;pred Optional[r: Feature -&gt; Feature] {&#x000a;&#x0009;r = GivenFeatureModel.optional&#x000a;}&#x000a;&#x000a;pred Alternative[r: Feature -&gt; Feature] {&#x000a;&#x0009;r = GivenFeatureModel.alternative&#x000a;}&#x000a;&#x000a;pred Or[r: Feature -&gt; Feature] {&#x000a;&#x0009;r = GivenFeatureModel._or&#x000a;}&#x000a;&#x000a;pred Requires[r: Feature -&gt; Feature] {&#x000a;&#x0009;r = GivenFeatureModel.requires&#x000a;}&#x000a;&#x000a;pred Excludes[r: Feature -&gt; Feature] {&#x000a;&#x0009;r + ~r = GivenFeatureModel.excludes&#x000a;}&#x000a;&#x000a;pred NoMandatory {&#x000a;&#x0009;no GivenFeatureModel.mandatory&#x000a;}&#x000a;&#x000a;pred NoOptional {&#x000a;&#x0009;no GivenFeatureModel.optional&#x000a;}&#x000a;&#x000a;pred NoAlternative {&#x000a;&#x0009;no GivenFeatureModel.alternative&#x000a;}&#x000a;&#x000a;pred NoOr {&#x000a;&#x0009;no GivenFeatureModel._or&#x000a;}&#x000a;&#x000a;pred NoRequires {&#x000a;&#x0009;no GivenFeatureModel.requires&#x000a;}&#x000a;&#x000a;pred NoExcludes {&#x000a;&#x0009;no GivenFeatureModel.excludes&#x000a;}&#x000a;&#x000a;pred NoRelations[m: FeatureModel] {&#x000a;&#x0009;no m.excludes&#x000a;&#x0009;no m.requires&#x000a;&#x0009;no m._or&#x000a;&#x0009;no m.alternative&#x000a;&#x0009;no m.mandatory&#x000a;&#x0009;no m.optional&#x000a;&#x0009;no m.depend&#x000a;}&#x000a;"/>

<source filename="/$alloy4$/models/util/relation.als" content="module util/relation&#x000a;&#x000a;/*&#x000a; * Utilities for some common operations and constraints&#x000a; * on binary relations. The keyword &apos;univ&apos; represents the&#x000a; * top-level type, which all other types implicitly extend.&#x000a; * Therefore, all the functions and predicates in this model&#x000a; * may be applied to binary relations of any type.&#x000a; *&#x000a; * author: Greg Dennis&#x000a; */&#x000a;&#x000a;/** returns the domain of a binary relation */&#x000a;fun dom [r: univ-&gt;univ] : set (r.univ) { r.univ }&#x000a;&#x000a;/** returns the range of a binary relation */&#x000a;fun ran [r: univ-&gt;univ] : set (univ.r) { univ.r }&#x000a;&#x000a;/** r is total over the domain s */&#x000a;pred total [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | some x.r&#x000a;}&#x000a;&#x000a;/** r is a partial function over the domain s */&#x000a;pred functional [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | lone x.r&#x000a;}&#x000a;&#x000a;/** r is a total function over the domain s */&#x000a;pred function [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | one x.r&#x000a;}&#x000a;&#x000a;/** r is surjective over the codomain s */&#x000a;pred surjective [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | some r.x&#x000a;}&#x000a;&#x000a;/** r is injective */&#x000a;pred injective [r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | lone r.x&#x000a;}&#x000a;&#x000a;/** r is bijective over the codomain s */&#x000a;pred bijective[r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | one r.x&#x000a;}&#x000a;&#x000a;/** r is a bijection over the domain d and the codomain c */&#x000a;pred bijection[r: univ-&gt;univ, d, c: set univ] {&#x000a;  function[r, d] &amp;&amp; bijective[r, c]&#x000a;}&#x000a;&#x000a;/** r is reflexive over the set s */&#x000a;pred reflexive [r: univ -&gt; univ, s: set univ] {s&lt;:iden in r}&#x000a;&#x000a;/** r is irreflexive */&#x000a;pred irreflexive [r: univ -&gt; univ] {no iden &amp; r}&#x000a;&#x000a;/** r is symmetric */&#x000a;pred symmetric [r: univ -&gt; univ] {~r in r}&#x000a;&#x000a;/** r is anti-symmetric */&#x000a;pred antisymmetric [r: univ -&gt; univ] {~r &amp; r in iden}&#x000a;&#x000a;/** r is transitive */&#x000a;pred transitive [r: univ -&gt; univ] {r.r in r}&#x000a;&#x000a;/** r is acyclic over the set s */&#x000a;pred acyclic[r: univ-&gt;univ, s: set univ] {&#x000a;  all x: s | x !in x.^r&#x000a;}&#x000a;&#x000a;/** r is complete over the set s */&#x000a;pred complete[r: univ-&gt;univ, s: univ] {&#x000a;  all x,y:s | (x!=y =&gt; x-&gt;y in (r + ~r))&#x000a;}&#x000a;&#x000a;/** r is a preorder (or a quasi-order) over the set s */&#x000a;pred preorder [r: univ -&gt; univ, s: set univ] {&#x000a;  reflexive[r, s]&#x000a;  transitive[r]&#x000a;}&#x000a;&#x000a;/** r is an equivalence relation over the set s */&#x000a;pred equivalence [r: univ-&gt;univ, s: set univ] {&#x000a;  preorder[r, s]&#x000a;  symmetric[r]&#x000a;}&#x000a;&#x000a;/** r is a partial order over the set s */&#x000a;pred partialOrder [r: univ -&gt; univ, s: set univ] {&#x000a;  preorder[r, s]&#x000a;  antisymmetric[r]&#x000a;}&#x000a;&#x000a;/** r is a total order over the set s */&#x000a;pred totalOrder [r: univ -&gt; univ, s: set univ] {&#x000a;  partialOrder[r, s]&#x000a;  complete[r, s]&#x000a;}&#x000a;"/>

<source filename="/home/harun/git/Demonstrations/eu.modelwriter.demonstration.alloyinecore/harun/Alloy/Improved Feature Model/Model_3/requirements_model.als" content="/** Takes a user defined signature and defines the relations according to it. */&#x000a;module requirements_model[Requirement]&#x000a;&#x000a;open util/relation&#x000a;&#x000a;abstract sig RequirementsModel {&#x000a;&#x0009;requires: Requirement -&gt; Requirement,&#x000a;&#x0009;refines: Requirement -&gt; Requirement,&#x000a;&#x0009;contains: Requirement -&gt; Requirement,&#x000a;&#x0009;partiallyRefines: Requirement -&gt; Requirement,&#x000a;&#x0009;conflicts: Requirement -&gt; Requirement,&#x000a;&#x0009;equals: Requirement -&gt; Requirement&#x000a;}&#x000a;&#x000a;/** EmptyModel is the model that has no relations, GivenModel is the model that user defines and InferredModel is the model that program infers. */&#x000a;one sig EmptyModel, GivenModel, InferredModel extends RequirementsModel {}&#x000a;&#x000a;/** There must be one relation between two requirements */&#x000a;private pred functional_facts[m:RequirementsModel]{&#x000a;&#x0009;no m.requires &amp; m.refines&#x000a;&#x0009;no m.requires &amp; m.contains&#x000a;&#x0009;no m.requires &amp; m.partiallyRefines&#x000a;&#x0009;no m.requires &amp; m.conflicts&#x000a;&#x0009;no m.requires &amp; m.equals&#x000a;&#x000a;&#x0009;no m.refines &amp; m.contains&#x000a;&#x0009;no m.refines &amp; m.partiallyRefines&#x000a;&#x0009;no m.refines &amp; m.conflicts&#x000a;&#x0009;no m.refines &amp; m.equals&#x000a;&#x000a;&#x0009;no m.contains &amp; m.partiallyRefines&#x000a;&#x0009;no m.contains &amp; m.conflicts&#x000a;&#x0009;no m.contains &amp; m.equals&#x000a;&#x000a;&#x0009;no m.partiallyRefines &amp; m.conflicts&#x000a;&#x0009;no m.partiallyRefines &amp; m.equals&#x000a;&#x000a;&#x0009;no m.conflicts &amp; m.equals&#x000a;&#x000a;&#x0009;no m.requires &amp; ~(m.refines)&#x000a;&#x0009;no m.requires &amp; ~(m.contains)&#x000a;&#x0009;no m.requires &amp; ~(m.partiallyRefines)&#x000a;&#x0009;no m.requires &amp; ~(m.conflicts)&#x000a;&#x0009;no m.requires &amp; ~(m.equals)&#x000a;&#x000a;&#x0009;no m.refines &amp; ~(m.contains)&#x000a;&#x0009;no m.refines &amp; ~(m.partiallyRefines)&#x000a;&#x0009;no m.refines &amp; ~(m.conflicts)&#x000a;&#x0009;no m.refines &amp; ~(m.equals)&#x000a;&#x000a;&#x0009;no m.contains &amp; ~(m.partiallyRefines)&#x000a;&#x0009;no m.contains &amp; ~(m.conflicts)&#x000a;&#x0009;no m.contains &amp; ~(m.equals)&#x000a;&#x000a;&#x0009;no m.partiallyRefines &amp; ~(m.conflicts)&#x000a;&#x0009;no m.partiallyRefines &amp; ~(m.equals)&#x000a;&#x000a;&#x0009;no m.conflicts &amp; ~(m.equals)&#x000a;}&#x000a;&#x000a;/** If a requirement equals to another requirement, then these requirements have exactly the same relations */&#x000a;private pred equals_facts[m:RequirementsModel] {&#x000a;&#x0009;all a,b: Requirement {&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.(m.conflicts) = b.(m.conflicts)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.(m.requires) = b.(m.requires)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.(m.equals) = b.(m.equals)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.(m.refines) = b.(m.refines)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.(m.partiallyRefines) = b.(m.partiallyRefines)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.(m.contains) = b.(m.contains)&#x000a;&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.~(m.conflicts) = b.~(m.conflicts)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.~(m.requires) = b.~(m.requires)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.~(m.equals) = b.~(m.equals)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.~(m.refines) = b.~(m.refines)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.~(m.partiallyRefines) = b.~(m.partiallyRefines)&#x000a;&#x0009;&#x0009;b in a.(m.equals) =&gt; a.~(m.contains) = b.~(m.contains)&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;/** Defines, under what conditions program should infer that one requirement requires another. */&#x000a;private pred infer_requires_facts[m:RequirementsModel] {&#x000a;&#x0009;all a,b,c: Requirement {&#x000a;&#x0009;&#x0009;b in a.(m.requires) &amp;&amp; c in b.(m.refines) &amp;&amp;  c !in a.(m.contains) =&gt; c in a.(m.requires)&#x000a;&#x0009;&#x0009;b in a.(m.refines) &amp;&amp; c in b.(m.requires) &amp;&amp;  c !in a.(m.contains) =&gt; c in a.(m.requires)&#x000a;&#x0009;&#x0009;b in a.(m.requires) &amp;&amp; c in b.(m.contains) &amp;&amp;  c !in a.(m.contains) =&gt; c in a.(m.requires)&#x000a;&#x0009;&#x0009;b in a.(m.contains) &amp;&amp; c in a.(m.requires) &amp;&amp;  c !in a.(m.contains) =&gt; c in a.(m.requires)&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;/** Defines, under what conditions program should infer that one requirement refines another. */&#x000a;private pred infer_refines_facts[m:RequirementsModel] {&#x000a;&#x0009;//all a,b,c: Requirement {&#x000a;&#x0009;//&#x0009;&#x000a;&#x0009;//}&#x000a;}&#x000a;&#x000a;/** Defines, under what conditions program should infer that one requirement partially refines another. */&#x000a;private pred infer_partiallyrefines_facts[m:RequirementsModel] {&#x000a;&#x0009;all a,b,c: Requirement {&#x000a;&#x0009;&#x0009;b in a.(m.contains) &amp;&amp; c in b.(m.refines) =&gt; c in a.(m.partiallyRefines)&#x000a;&#x0009;&#x0009;b in a.(m.refines) &amp;&amp; c in b.(m.contains) =&gt; c in a.(m.partiallyRefines)&#x000a;&#x0009;&#x0009;b in a.(m.partiallyRefines) &amp;&amp; c in b.(m.contains) =&gt; c in a.(m.partiallyRefines)&#x000a;&#x0009;&#x0009;b in a.(m.contains) &amp;&amp; c in b.(m.partiallyRefines) =&gt; c in a.(m.partiallyRefines)&#x000a;&#x0009;&#x0009;b in a.(m.refines) &amp;&amp; c in b.(m.partiallyRefines) =&gt; c in a.(m.partiallyRefines)&#x000a;&#x0009;&#x0009;b in a.(m.partiallyRefines) &amp;&amp; c in b.(m.refines) =&gt; c in a.(m.partiallyRefines)&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;/** Defines, under what conditions program should infer that one requirement conflicts another. */&#x000a;private pred infer_conflicts_facts[m:RequirementsModel] {&#x000a;&#x0009;all a,b,c: Requirement {&#x000a;&#x0009;&#x0009;b in a.(m.requires + m.refines + m.contains) &amp;&amp; c in b.(m.conflicts) =&gt; c in a.(m.conflicts)&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;/** Defines, what conditions are required to infer relations. It assures that program doesn&apos;t infer irrelevant relations and gives only the accurate solutions. */&#x000a;private pred relation_facts[m,m&apos;: RequirementsModel] {&#x000a;&#x0009;all a,c: Requirement {&#x000a;&#x0009;&#x0009;c in a.(m&apos;.equals) =&gt; c in a.*(m.equals + ~(m.equals))&#x000a;&#x0009;&#x0009;c in a.(m&apos;.requires) =&gt; c in a.*(m.requires + m.contains + m.refines + m&apos;.equals) // If &quot;a&quot; requires &quot;c&quot; in the inferred model, then we must somehow reach &quot;c&quot; from &quot;a&quot; in the given model by using requires, contains and refines relations.&#x000a;&#x0009;&#x0009;c in a.(m&apos;.refines) =&gt; c in a.*(m.requires + m.refines + m&apos;.equals).*(m.contains + m&apos;.equals) // Same logic here.&#x000a;&#x0009;&#x0009;c in a.(m&apos;.contains) =&gt; c in a.*(m.contains + m&apos;.equals) // Same logic here.&#x000a;&#x0009;&#x0009;c in a.(m&apos;.partiallyRefines) =&gt; c in a.*(m.(refines + partiallyRefines) + m&apos;.equals).*(m.contains + m&apos;.equals) // Same logic here.&#x000a;&#x0009;&#x0009;c in a.(m&apos;.conflicts) =&gt; &#x0009;c in a.(m.requires + m.refines + m.contains + m&apos;.equals).(m.conflicts + ~(m.conflicts)).*(m&apos;.equals) || // If a conflicts with c in the inferred model, then in the given model, either a conflicts with c or what is required by a, conflicts with c.&#x000a;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009;&#x0009; &#x0009;&#x0009;c in a.*(m&apos;.equals).(m.conflicts + ~(m.conflicts)).*~(m.requires + m.refines + m.contains + m&apos;.equals)&#x0009;// Reverse logic here.&#x000a;&#x0009;}&#x000a;}&#x000a;&#x000a;/** The definitions of relations. */&#x000a;private pred relation_properties[m&apos;:RequirementsModel] {&#x000a;&#x0009;irreflexive[m&apos;.requires]&#x000a;&#x0009;antisymmetric[m&apos;.requires]&#x000a;&#x0009;transitive[m&apos;.requires]&#x000a;&#x000a;&#x0009;irreflexive[m&apos;.refines]&#x000a;&#x0009;antisymmetric[m&apos;.refines]&#x000a;&#x0009;transitive[m&apos;.refines]&#x000a;&#x000a;&#x0009;irreflexive[m&apos;.contains]&#x000a;&#x0009;antisymmetric[m&apos;.contains]&#x000a;&#x0009;transitive[m&apos;.contains]&#x000a;&#x000a;&#x0009;irreflexive[m&apos;.partiallyRefines]&#x000a;&#x0009;antisymmetric[m&apos;.partiallyRefines]&#x000a;&#x0009;transitive[m&apos;.partiallyRefines]&#x000a;&#x000a;&#x0009;irreflexive[m&apos;.conflicts]&#x000a;&#x0009;symmetric[m&apos;.conflicts]&#x000a;&#x000a;&#x0009;reflexive[m&apos;.equals, Requirement] // It was said non-reflexive in the article but it was logically wrong and gave no result.&#x000a;&#x0009;symmetric[m&apos;.equals]&#x000a;&#x0009;transitive[m&apos;.equals]&#x000a;}&#x000a;&#x000a;/** Takes the given model, places the relations into the second model and infers new relations. */&#x000a;fact generateSolution {&#x000a;&#x0009;GivenModel.requires in InferredModel.requires&#x000a;&#x0009;GivenModel.refines in InferredModel.refines&#x000a;&#x0009;GivenModel.contains in InferredModel.contains&#x000a;&#x0009;GivenModel.partiallyRefines in InferredModel.partiallyRefines&#x000a;&#x0009;GivenModel.conflicts in InferredModel.conflicts&#x000a;&#x0009;GivenModel.equals in InferredModel.equals&#x000a;&#x000a;&#x0009;relation_properties[InferredModel]&#x000a;&#x0009;infer_conflicts_facts[InferredModel]&#x000a;&#x0009;infer_refines_facts[InferredModel]&#x000a;&#x0009;infer_partiallyrefines_facts[InferredModel]&#x000a;&#x0009;infer_requires_facts[InferredModel]&#x000a;&#x0009;equals_facts[InferredModel]&#x000a;&#x0009;functional_facts[InferredModel]&#x000a;&#x0009;relation_facts[GivenModel, InferredModel]&#x000a;&#x000a;&#x0009;NoRelations[EmptyModel]&#x000a;}&#x000a;&#x000a;/***********************************************************************************************************/&#x000a;/***********************************************************************************************************/&#x000a;&#x000a;/** Makes sure that r1 requires r2 */&#x000a;pred Requires[r1,r2: Requirement] { &#x000a;&#x0009;r1 -&gt; r2 in GivenModel.requires&#x000a;}&#x000a;&#x000a;/** Makes sure that r1 refines r2 */&#x000a;pred Refines[r1,r2: Requirement] { &#x000a;&#x0009;r1 -&gt; r2 in GivenModel.refines&#x000a;}&#x000a;&#x000a;/** Makes sure that r1 partially refines r2 */&#x000a;pred PartiallyRefines[r1,r2: Requirement] { &#x000a;&#x0009;r1 -&gt; r2 in GivenModel.partiallyRefines&#x000a;}&#x000a;&#x000a;/** Makes sure that r1 conflicts r2 */&#x000a;pred Conflicts[r1,r2: Requirement] { &#x000a;&#x0009;r1 -&gt; r2 in GivenModel.conflicts&#x000a;}&#x000a;&#x000a;/** Makes sure that r1 equals r2 */&#x000a;pred Equals[r1,r2: Requirement] { &#x000a;&#x0009;r1 -&gt; r2 in GivenModel.equals&#x000a;}&#x000a;&#x000a;/** Makes sure that r1 contains r2 */&#x000a;pred Contains[r1,r2: Requirement] { &#x000a;&#x0009;r1 -&gt; r2 in GivenModel.contains&#x000a;}&#x000a;&#x000a;/** Takes a set of relations and makes it equal to requires relation in the user defined model */&#x000a;pred Requires[r: Requirement -&gt; Requirement]{&#x000a;&#x0009;r = GivenModel.requires&#x000a;}&#x000a;&#x000a;/** Takes a set of relations and makes it equal to refines relation in the user defined model */&#x000a;pred Refines[r: Requirement -&gt; Requirement]{&#x000a;&#x0009;r = GivenModel.refines&#x000a;}&#x000a;&#x000a;/** Takes a set of relations and makes it equal to partially refines relation in the user defined model */&#x000a;pred PartiallyRefines[r: Requirement -&gt; Requirement]{&#x000a;&#x0009;r = GivenModel.partiallyRefines&#x000a;}&#x000a;&#x000a;/** Takes a set of relations and makes it equal to conflicts relation in the user defined model */&#x000a;pred Conflicts[r: Requirement -&gt; Requirement]{&#x000a;&#x0009;r = GivenModel.conflicts&#x000a;}&#x000a;&#x000a;/** Takes a set of relations and makes it equal to equals relation in the user defined model */&#x000a;pred Equals[r: Requirement -&gt; Requirement]{&#x000a;&#x0009;r = GivenModel.equals&#x000a;}&#x000a;&#x000a;/** Takes a set of relations and makes it equal to conflicts relation in the user defined model */&#x000a;pred Contains[r: Requirement -&gt; Requirement]{&#x000a;&#x0009;r = GivenModel.contains&#x000a;}&#x000a;&#x000a;/** Makes sure that there are no requires relations in the user defined model */&#x000a;pred NoRequires {&#x000a;&#x0009;no GivenModel.requires&#x000a;}&#x000a;&#x000a;/** Makes sure that there are no refines relations in the user defined model */&#x000a;pred NoRefines {&#x000a;&#x0009;no GivenModel.refines&#x000a;}&#x000a;&#x000a;/** Makes sure that there are no partially refines relations in the user defined model */&#x000a;pred NoPartiallyRefines {&#x000a;&#x0009;no GivenModel.partiallyRefines&#x000a;}&#x000a;&#x000a;/** Makes sure that there are no conflicts relations in the user defined model */&#x000a;pred NoConflicts {&#x000a;&#x0009;no GivenModel.conflicts&#x000a;}&#x000a;&#x000a;/** Makes sure that there are no equals relations in the user defined model */&#x000a;pred NoEquals {&#x000a;&#x0009;no GivenModel.equals&#x000a;}&#x000a;&#x000a;/** Makes sure that there are no contains relations in the user defined model */&#x000a;pred NoContains {&#x000a;&#x0009;no GivenModel.contains&#x000a;}&#x000a;&#x000a;/** Makes sure that there are no relations in requirements model given as parameter */&#x000a;pred NoRelations[m: RequirementsModel] {&#x000a;&#x0009;no m.contains&#x000a;&#x0009;no m.equals&#x000a;&#x0009;no m.conflicts&#x000a;&#x0009;no m.refines&#x000a;&#x0009;no m.partiallyRefines&#x000a;&#x0009;no m.requires&#x000a;}&#x000a;"/>

</alloy>
